h2. A Simple Stack - when a new expectation passes - IN PROGRESS - DISREGARD THIS PAGE

At this point stack_spec.rb should look like this...

<ruby>
require 'stack'

context "A new stack" do
  setup do
    @stack = Stack.new
  end

  specify "should be empty" do
    @stack.should_be_empty
  end
end

context "An empty stack" do
  setup do
    @stack = Stack.new
  end

  specify "should not be empty after 'push'" do
    @stack.push 37
    @stack.should_not_be_empty
  end
end
  
context "A stack with one item" do
  setup do
    @stack = Stack.new
    @stack.push "one item"
  end

  specify "should return top when you send it 'top'" do
    @stack.top.should_equal "one item"
  end
end
</ruby>

stack.rb should look like this...

<ruby>
class Stack
  def empty?
    @item.nil?
  end
  def push item
    @item = item
  end
  def top
     @item
  end
end
</ruby>

...and the output should look like this:

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

An empty stack
- should not be empty after 'push'

A stack with one item
- should return top when you send it 'top'

Finished in 0.000741 seconds

3 contexts, 4 specifications, 0 failures
</pre>

Again, a really nice feature of using the <code>--format specdoc</code> option (<code>-f s</code> for short) is that you can see the big picture very clearly.

Look closely at the "An empty stack" context. We say that it "should not be empty after 'push'". Does that strike you as confusing? It may not, but if you think about it, we're taking an object in one state ("An empty stack"), changing its state by pushing an item onto it and THEN setting an expectation about it. You could argue that we're not really specifying behaviour of an empty stack at all here, but rather behaviour of a stack with one element when you call push.

So let's add that spec to "A stack with one item".

<ruby>
context "A stack with one item" do
  setup do
    @stack = Stack.new
    @stack.push "one item"
  end

  specify "should return top when you send it 'top'" do
    @stack.top.should_equal "one item"
  end
  
  specify "should not be empty" do
    @stack.should_not_be_empty
  end
end
</ruby>

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

An empty stack
- should not be empty after 'push'

A stack with one item
- should return top when you send it 'top'
- should not be empty

Finished in 0.000849 seconds

3 contexts, 4 specifications, 0 failures
</pre>

And now we can just remove "An empty spec" from stack_spec.rb.

<ruby>
require 'stack'

context "A new stack" do
  setup do
    @stack = Stack.new
  end
  specify "should be empty" do
    @stack.should_be_empty
  end
end

context "A stack with one item" do
  setup do
    @stack = Stack.new
    @stack.push "one item"
  end

  specify "should return top when you send it 'top'" do
    @stack.top.should_equal "one item"
  end
  
  specify "should not be empty" do
    @stack.should_not_be_empty
  end
end
</ruby>

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

A stack with one item
- should return top when you send it 'top'
- should not be empty

Finished in 0.000565 seconds

2 contexts, 3 specifications, 0 failures
</pre>

So keep your eye on the contexts and specifications as they evolve. Don't be afraid to move specs around. There are many different benefits that we get from these executable specifications. One is that it helps us to drive code, resulting in very simple and well tested code. Another very important benefit is that future developers can look at them and understand how to use a component (module, class, method, etc). Keep them in mind. "They" may even be you!

<a href="stack_03.html">Previous</a>
