h2. A Simple Stack - Top - IN PROGRESS - DISREGARD THIS PAGE

What should happen when you call top on an empty stack? We could just return nil, 
but how does the client know whether the stack was empty or contained nil as an element? 
Perhaps the client doesn't care. Let's assume the client does care, in which case we'd want to raise an error.

We already have our "empty stack" context, so let's add a specification to it.

<ruby>
context "An empty stack" do
  
  setup do
    @stack = Stack.new
  end
  
  specify "should keep its mouth shut when you send it 'push'" do
     lambda { @stack.push Object.new }.should_not_raise Exception
  end
  
  specify "should raise a StackUnderflowError when you send it 'top'" do
    lambda { @stack.top }.should_raise StackUnderflowError
  end
  
end
</ruby>

Running the spec...

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'
- should raise a StackUnderflowError when you send it 'top' (FAILED - 1)

A stack with one item
- should return top when you send it 'top'


1)
NameError in 'An empty stack should raise a StackUnderflowError when you send it 'top''
uninitialized constant StackUnderflowError
./stack_spec.rb:14:in `should raise a StackUnderflowError when you send it 'top''

Finished in 0.000582 seconds

2 contexts, 3 specifications, 1 failure
</pre>

"uninitialized constant StackUnderflowError" tells us that we need to create a StackUndeflowError. We'll just stick that in the file with the Stack:

<ruby>
class StackUnderflowError < RuntimeError
end
</ruby>

and run the spec again.

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'
- should raise a StackUnderflowError when you send it 'top' (FAILED - 1)

A stack with one item
- should return top when you send it 'top'


1)
ExpectationNotMetError in 'An empty stack should raise a StackUnderflowError when you send it 'top''
<Proc> should raise <StackUnderflowError> but raised nothing
./stack_spec.rb:14:in `should raise a StackUnderflowError when you send it 'top''

Finished in 0.000788 seconds

2 contexts, 3 specifications, 1 failure
</pre>

Now the error report tells us that the expectation was not met - executing the block did not 
raise the error we specified. Now we can implement code to meet this specification. Sticking 
with the principle that we want to implement the least amount of code to meet the specification, 
we enhance our top method:

<ruby>
def top
  raise StackUnderflowError if @item.nil?
  @item
end
</ruby>

run the specs and they all pass.

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'
- should raise a StackUnderflowError when you send it 'top'

A stack with one item
- should return top when you send it 'top'


Finished in 0.000557 seconds

2 contexts, 3 specifications, 0 failures
</pre>

Do you see how the verbose output is looking more and more like a specification? That's pretty nice, but as your projects grow, you may not want all of that output all of the time. You can, if you wish, run the specs without the <code>-v</code> flag, in which case you get a "." for every passing spec and an "F" for every failing spec. Run them now and you'll see nothing but dots.

<pre>
$ spec stack_spec.rb 

...

Finished in 0.000458 seconds

2 contexts, 3 specifications, 0 failures
</pre>

<a href="stack_02.html">Previous</a> |
<a href="stack_04.html">Next</a>