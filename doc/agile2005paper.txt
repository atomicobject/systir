---+ Domain-Specific System Test Automation with SYSTIR

In this paper we present a new system testing framework that encourages a handful of recent ideas in the realm of automated system testing.

---++ What We Have Now

Modern frameworks for automated system testing fall into three categories.  Some are capture/replay-based systems.  These require recording a user's actions and allow automated replay and verification of the results.  Some provide a vendor-specific language to write high-level scripts that describe test cases.  Finally, recent test automation frameworks [1][2] allow table- or keyword-based test descriptions that usually form a more data-driven approach utilizing a rigid, minimal syntax.  Even hybrids of these types exist,  such as recording scripts using a high-level language that allows hand customization or even data-driven parameterization.

The first category, capture/replay systems (also known as record/playback,) tout their ease-of-use and short test authoring times.  They allow large feature coverage only for a specific build of the application under test (AUT).  Subsequent changes to the AUT will require re-recording the scripts because of a close coupling to the presentation layer. Prominent software testing consultant and co-auther of _Lessons Learned in Software Testing_, Brett Pettichord remarked in 2001 that "record and playback tools provide an easy way to create throwaway testsuites." Recordings of an application can only be created once the application is actually built.

Test automation suites that instead provide their own scripting languages do little to address these problems.  We call these Vendor-Specific Languages (VSLs, also known as vendorscripts[4].)  They tout flexibility and easy-to-learn syntax.  They provide a micro-language for testers, usually including assertion keywords and simple looping constructs.  They offer greater data parameterization over capture/replay by replacing user input with stored data sets.  However, it's still up to testers to connect the testing languages abilities to their problem space.  The resulting glue code can become the hardest to maintain as developers provide a moving target AUT for testers to attach suites to.  VSLs are also fragile in the same way that capture/replay systems are.  They are written against an existing build and are closely coupled to the presentation layer.

Other test automation systems implement what Danny Faught calls "keyword" testing.  Systems such as FITnesse, CompuWare(what?) and Selenium are examples.  They provide a set of simple "keywords" to describe test actions.  Tests are often represented in a table structure, sometimes in actual spreadsheets.  While tests allow a very small set of operations, they usually offer much easier writeability.  Many offer strong data parameterization capabilities.  

---++ Tester And Toolsmith
(desc. of tester/toolsmith relationship)

Too many custom domain-specific languages require test writers to write code.  Testers are not always trained to utilize development techniques such as encapsulation or polymorphism, however.  Keyword testing only offers a solution at the cost of flexibility.  The result is that the test scripts written remain just that: scripts.  They cannot be reused outside of their original context.  Vendorscript language implementors try to counteract this frailty by adding features such as macro processing or bolted-on object oriented features.  The languages grow so that the most powerful tend to be too complex for testers to apply efficiently.  The ones that aren't too large are usually too limited.  Something is needed to help the testers strike a balance between test flexibility and test component reuse.

Enter the Toolsmith[3].  A Toolsmith is a developer who writes software for other developers.  In our case, the other developer is instead a tester.  The toolsmith's job is too provide the tester with the tools necessary to make testing an application easy and repeatable.  By pairing the two together, you end up with just enough testing and domain knowledge combined with just enough custom development.  The Toolsmith enables the tester to focus on writing tests in their own problem space, that of the application.  Meanwhile the tester lightens the load of the developer by handling the "rote" work of writing and running test cases.

This relationship proves ideal for both people involved.  Developers would rather write "interesting" code that solves specific problems.  Testers would rather write interesting test cases that challenge the AUT and excercise its functionality.

---++ What makes ruby a good choice

An open source Ruby has become known for its applicability in domain-specific languages.  Ruby's dynamic typing and object-oriented self-modification allows its users to quickly create customized languages that read like natural language.  It's =perl=-inspired relaxed syntax allows for freedoms that aid in readability without sacrificing capability.  Optional semicolons and parentheses are an example of this.  Dave Thomas of the Pragmatic Programmers has highlighted Ruby's use as a generative language.

<blockquote>
   "With Ruby you write programs close to the problem domain. Rather than constantly mapping your ideas and designs down to the pedestrian level of most languages, with Ruby you'll find you can express them directly and express them elegantly. This means you code faster. It also means your programs stay readable and maintainable."
</blockquote>

---++ Save me, SYSTIR
SYSTIR implements a system test autmation framework that is both simple to extend and simple to use without requiring testers to learn a proprietary script language.  The actual SYSTIR project is very light on code yet heavy on idealogy.  It provides a simple test aggregation mechanism,

---++ SYSTIR supports tester/toolsmith

---++ SYSTIR supports reuse
(about building reusable, generic-enough SYSTIR drivers)

---++ SYSTIR on Display
(Example data, WATIR integration, AWTA)

---++ SYSTIR's future
(reporting, bundled driveers, whatever else we think we'll do)

---++ References

   * [1] Selenium
   * [2] FITnesse
   * [3] Jargon file
   * [4] Brett's vendorscript paper
   * more of course
