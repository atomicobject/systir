Every software developer has the same initial problem: you have to know what the software is supposed to *do* in order to implement it.  The buyers or users of software have a similarly eternal problem:
they just want what they pay for to do exactly what they want.

So, it's actually the same problem.  The developer and the user agree at some point on the expected features and behaviours.  If your still in the dark ages, you may have a customer who writes down everything they want their software to do and then hands it off to the developer for implementation.  This works poorly or not at all.  If you're an Agile shop, you might have a head start.  Here a customer might define requirements during a planning game session before each iteration.  Now at least we have the requirements that meet current need, on easily digestable note cards.

Unfortunately, neither is sufficient for ensuring the customer is getting what they want.  Quick iterations can aleviate the problem by letting the customer peek in and review often.  But how often?  Every week?  Every two weeks?  What if they change their mind on Wednesday?  What if they were just tired Monday morning?

The only way to be sure that every feature you write is desired and correct is to test it.  If you're busy developing those features, you can't be expected to stop and walk through an excel spreadsheet of every possible user scenario every time you commit code.  Automation is the only way to allow  

Systir is about users and customers writing their own system tests.  By system tests, I mean the not unit or functional tests.  

RubyConf: These are also called acceptance tests, or integration tests.  The terminology varies widely but the main distinction here is in the type of isolation your tests undergo.  In system tests, your are cross-cutting the software functional set to test usually a single user experience or system requirement.  In unit tests of course we cherry-pick, strongly isolating and testing little bits exlusively.

